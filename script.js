// Generated by Haxe 3.4.7
(function () { "use strict";
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var Cube = function() {
	THREE.Object3D.call(this);
	var ww = 100.;
	var mate = new THREE.LineBasicMaterial({ color : color_MyColors.lineA});
	var _g = 0;
	while(_g < 4) {
		var i = _g++;
		var geo = this._getGeometry(ww);
		var line = new THREE.Line(geo,mate);
		this.add(line);
		line.rotation.x = i * Math.PI / 2;
	}
	var geo1 = new THREE.Geometry();
	var w = 30;
	var hh = 100;
	geo1.vertices.push(new THREE.Vector3(w,hh,0));
	geo1.vertices.push(new THREE.Vector3(w,0,0));
	geo1.vertices.push(new THREE.Vector3(-w,0,0));
	geo1.vertices.push(new THREE.Vector3(-w,hh,0));
	geo1.vertices.push(new THREE.Vector3(w,hh,0));
	var line1 = new THREE.Line(geo1,mate);
	line1.position.y = -hh;
	line1.position.z = -ww;
	var mesh = new THREE.Mesh(new THREE.BoxGeometry(ww * 2,ww * 2,ww * 2),new cube_CubeShaderMat());
};
Cube.__super__ = THREE.Object3D;
Cube.prototype = $extend(THREE.Object3D.prototype,{
	_getGeometry: function(ww) {
		var geo = new THREE.Geometry();
		geo.vertices.push(new THREE.Vector3(ww,ww,ww));
		geo.vertices.push(new THREE.Vector3(ww,-ww,ww));
		geo.vertices.push(new THREE.Vector3(-ww,-ww,ww));
		geo.vertices.push(new THREE.Vector3(-ww,ww,ww));
		geo.vertices.push(new THREE.Vector3(ww,ww,ww));
		return geo;
	}
	,update: function() {
	}
});
var HxOverrides = function() { };
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
var Main = function() {
	this._amp = 300;
	this._mouseY = 0;
	this._mouseX = 0;
	this._count = 0;
	window.onload = $bind(this,this.initialize);
};
Main.main = function() {
	new Main();
};
Main.prototype = {
	initialize: function(e) {
		var _gthis = this;
		this._verletsList = [];
		this._scene = new THREE.Scene();
		this._camera = new THREE.PerspectiveCamera(48,window.innerWidth / window.innerHeight,1,5000);
		this._camera.position.z = 100;
		this._camera.lookAt(new THREE.Vector3());
		var s = 3;
		this._camera.lookAt(new THREE.Vector3());
		this._renderer = new THREE.WebGLRenderer({ devicePixelRatio : 1});
		this._renderer.setClearColor(new THREE.Color(color_MyColors.bg));
		this._renderer.setSize(window.innerWidth,window.innerHeight);
		window.document.body.appendChild(this._renderer.domElement);
		this.directionalLight = new THREE.DirectionalLight(color_MyColors.directionalLight,1.4);
		this.directionalLight.position.x = 200;
		this.directionalLight.position.y = 2000;
		this.directionalLight.position.z = 200;
		this._scene.add(this.directionalLight);
		var ambient = new THREE.AmbientLight(color_MyColors.ambientLight);
		this._scene.add(ambient);
		this._cube = new Cube();
		this._onHoge(null);
		this._run();
		this._onResize();
		window.onresize = $bind(this,this._onResize);
		window.onwheel = function(e1) {
			_gthis._amp += e1.wheelDelta * 0.5;
			if(_gthis._amp < 1) {
				_gthis._amp = 1;
			}
			if(_gthis._amp > 5000) {
				_gthis._amp = 5000;
			}
		};
		window.onmousedown = $bind(this,this._onHoge);
		window.ontouchstart = $bind(this,this._onHoge);
    setInterval($bind(this,this._onHoge),10000);
	}
	,_onHoge: function(e) {
		this._scene.remove(this._verlets);
		this._verlets = new verlet_VerletPoints();
		this._verlets.init();
		this._scene.add(this._verlets);
		this._verletsList[0] = this._verlets;
	}
	,_run: function() {
		this._cube.update();
		var _g1 = 0;
		var _g = this._verletsList.length;
		while(_g1 < _g) {
			var i = _g1++;
			this._verletsList[i].rotation.y = this._cube.rotation.y;
			this._verletsList[i].update();
		}
		this._camera.position.z = this._amp;
		this._renderer.render(this._scene,this._camera);
		window.requestAnimationFrame($bind(this,this._run));
	}
	,_onResize: function() {
		this._camera.aspect = window.innerWidth / window.innerHeight;
		this._camera.updateProjectionMatrix();
		this._renderer.setSize(window.innerWidth,window.innerHeight);
	}
};
var Three = function() { };
Three.requestAnimationFrame = function(f) {
	return window.requestAnimationFrame(f);
};
Three.cancelAnimationFrame = function(f) {
	window.cancelAnimationFrame(id);
};
var color_MyColors = function() {
};
var cube_CubeShaderMat = function() {
	this.ff = "\r\n\t\t//uniform å¤‰æ•°ã¨ã—ã¦ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ãƒ‡ãƒ¼ã‚¿ã‚’å—ã‘å–ã‚‹\r\n\t\tuniform float counter;\r\n\t\t// vertexShaderã§å‡¦ç†ã•ã‚Œã¦æ¸¡ã•ã‚Œã‚‹ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™\r\n\t\tvarying vec2 vUv;                                             \r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\t\t  // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®è‰²æƒ…å ±ã‚’ãã®ã¾ã¾ãƒ”ã‚¯ã‚»ãƒ«ã«å¡—ã‚‹\r\n\t\t  //gl_FragColor = vec4(0.8, 1.0, 0.4, 1.0);\r\n\t\t  \r\n\t\t  gl_FragColor = vec4(1.0, 0.8, 1.0, 1.0);\r\n\t\t  \r\n\t\t}\t\r\n\t";
	this.vv = "\r\n\t\tvarying vec2 vUv;// fragmentShaderã«æ¸¡ã™ãŸã‚ã®varyingå¤‰æ•°\r\n\t\tvoid main()\r\n\t\t{\r\n\t\t  // å‡¦ç†ã™ã‚‹é ‚ç‚¹ã”ã¨ã®uv(ãƒ†ã‚¯ã‚¹ãƒãƒ£)åº§æ¨™ã‚’ãã®ã¾ã¾fragmentShaderã«æ¨ªæµã—ã™ã‚‹\r\n\t\t  vUv = uv;\r\n\t\t  // å¤‰æ›ï¼šãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ â†’ é…ç½® â†’ ã‚«ãƒ¡ãƒ©åº§æ¨™\r\n\t\t  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);    \r\n\t\t  // å¤‰æ›ï¼šã‚«ãƒ¡ãƒ©åº§æ¨™ â†’ ç”»é¢åº§æ¨™\r\n\t\t  vec4 vv = projectionMatrix * mvPosition;\r\n\t\t vv.z += 0.1;\r\n\t\t  gl_Position = vv;\r\n\t\t}\r\n\t";
	THREE.ShaderMaterial.call(this,{ vertexShader : this.vv, fragmentShader : this.ff, uniforms : { }});
	this.side = 1;
};
cube_CubeShaderMat.__super__ = THREE.ShaderMaterial;
cube_CubeShaderMat.prototype = $extend(THREE.ShaderMaterial.prototype,{
	update: function() {
	}
});
var mat_MyShaderMat = function(deform) {
	if(deform == null) {
		deform = 1;
	}
	this.ff = "\r\n//\r\n// Description : Array and textureless GLSL 2D/3D/4D simplex \r\n//               noise functions.\r\n//      Author : Ian McEwan, Ashima Arts.\r\n//  Maintainer : ijm\r\n//     Lastmod : 20110822 (ijm)\r\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\r\n//               Distributed under the MIT License. See LICENSE file.\r\n//               https://github.com/ashima/webgl-noise\r\n// \r\n\r\nvec3 mod289(vec3 x) {\r\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec4 mod289(vec4 x) {\r\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec4 permute(vec4 x) {\r\n\treturn mod289(((x*34.0)+1.0)*x);\r\n}\r\n\r\nvec4 taylorInvSqrt(vec4 r){\r\n\treturn 1.79284291400159 - 0.85373472095314 * r;\r\n}\r\n\r\nfloat snoise(vec3 v) { \r\n\r\n\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\r\n\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\r\n\r\n\t// First corner\r\n\tvec3 i  = floor(v + dot(v, C.yyy) );\r\n\tvec3 x0 =   v - i + dot(i, C.xxx) ;\r\n\r\n\t// Other corners\r\n\tvec3 g = step(x0.yzx, x0.xyz);\r\n\tvec3 l = 1.0 - g;\r\n\tvec3 i1 = min( g.xyz, l.zxy );\r\n\tvec3 i2 = max( g.xyz, l.zxy );\r\n\r\n\t//   x0 = x0 - 0.0 + 0.0 * C.xxx;\r\n\t//   x1 = x0 - i1  + 1.0 * C.xxx;\r\n\t//   x2 = x0 - i2  + 2.0 * C.xxx;\r\n\t//   x3 = x0 - 1.0 + 3.0 * C.xxx;\r\n\tvec3 x1 = x0 - i1 + C.xxx;\r\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\r\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\r\n\r\n\t// Permutations\r\n\ti = mod289(i); \r\n\tvec4 p = permute( permute( permute( \r\n\t\t  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\r\n\t\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \r\n\t\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\r\n\r\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\r\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\r\n\tfloat n_ = 0.142857142857; // 1.0/7.0\r\n\tvec3  ns = n_ * D.wyz - D.xzx;\r\n\r\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\r\n\r\n\tvec4 x_ = floor(j * ns.z);\r\n\tvec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\r\n\r\n\tvec4 x = x_ *ns.x + ns.yyyy;\r\n\tvec4 y = y_ *ns.x + ns.yyyy;\r\n\tvec4 h = 1.0 - abs(x) - abs(y);\r\n\r\n\tvec4 b0 = vec4( x.xy, y.xy );\r\n\tvec4 b1 = vec4( x.zw, y.zw );\r\n\r\n\t//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\r\n\t//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\r\n\tvec4 s0 = floor(b0)*2.0 + 1.0;\r\n\tvec4 s1 = floor(b1)*2.0 + 1.0;\r\n\tvec4 sh = -step(h, vec4(0.0));\r\n\r\n\tvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\r\n\tvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\r\n\r\n\tvec3 p0 = vec3(a0.xy,h.x);\r\n\tvec3 p1 = vec3(a0.zw,h.y);\r\n\tvec3 p2 = vec3(a1.xy,h.z);\r\n\tvec3 p3 = vec3(a1.zw,h.w);\r\n\r\n\t//Normalise gradients\r\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\r\n\tp0 *= norm.x;\r\n\tp1 *= norm.y;\r\n\tp2 *= norm.z;\r\n\tp3 *= norm.w;\r\n\r\n\t// Mix final noise value\r\n\tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\r\n\tm = m * m;\r\n\treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\r\n\r\n}\r\n\r\nvec3 snoiseVec3( vec3 x ){\r\n\r\n\tfloat s  = snoise(vec3( x ));\r\n\tfloat s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\r\n\tfloat s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\r\n\tvec3 c = vec3( s , s1 , s2 );\r\n\treturn c;\r\n\r\n}\r\n\r\nvec3 snoiseVec3Abs( vec3 x ){\r\n\r\n\tfloat s  = snoise(vec3( x ));\r\n\tfloat s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\r\n\tfloat s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\r\n\tvec3 c = vec3( abs(s) , abs(s1) , abs(s2) );\r\n\treturn c;\r\n\r\n}\r\n\r\n\r\nvec3 curlNoise( vec3 p ){\r\n \r\n\tconst float e = .1;\r\n\tvec3 dx = vec3( e   , 0.0 , 0.0 );\r\n\tvec3 dy = vec3( 0.0 , e   , 0.0 );\r\n\tvec3 dz = vec3( 0.0 , 0.0 , e   );\r\n\r\n\tvec3 p_x0 = snoiseVec3( p - dx );\r\n\tvec3 p_x1 = snoiseVec3( p + dx );\r\n\tvec3 p_y0 = snoiseVec3( p - dy );\r\n\tvec3 p_y1 = snoiseVec3( p + dy );\r\n\tvec3 p_z0 = snoiseVec3( p - dz );\r\n\tvec3 p_z1 = snoiseVec3( p + dz );\r\n\r\n\tfloat x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\r\n\tfloat y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\r\n\tfloat z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\r\n\r\n\tconst float divisor = 1.0 / ( 2.0 * e );\r\n\treturn normalize( vec3( x , y , z ) * divisor );\r\n\r\n}\r\n\r\nvec3 curlNoise2( vec3 p ) {\r\n\r\n\tconst float e = .1;\r\n\r\n\tvec3 xNoisePotentialDerivatives = snoiseVec3( p );\r\n\tvec3 yNoisePotentialDerivatives = snoiseVec3( p + e * vec3( 3., -3.,  1. ) );\r\n\tvec3 zNoisePotentialDerivatives = snoiseVec3( p + e * vec3( 2.,  4., -3. ) );\r\n\r\n\tvec3 noiseVelocity = vec3(\r\n\t\tzNoisePotentialDerivatives.y - yNoisePotentialDerivatives.z,\r\n\t\txNoisePotentialDerivatives.z - zNoisePotentialDerivatives.x,\r\n\t\tyNoisePotentialDerivatives.x - xNoisePotentialDerivatives.y\r\n\t);\r\n\r\n\treturn normalize( noiseVelocity );\r\n\r\n}\r\n\r\nvec4 snoiseD(vec3 v) { //returns vec4(value, dx, dy, dz)\r\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\r\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\r\n \r\n  vec3 i  = floor(v + dot(v, C.yyy) );\r\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\r\n \r\n  vec3 g = step(x0.yzx, x0.xyz);\r\n  vec3 l = 1.0 - g;\r\n  vec3 i1 = min( g.xyz, l.zxy );\r\n  vec3 i2 = max( g.xyz, l.zxy );\r\n \r\n  vec3 x1 = x0 - i1 + C.xxx;\r\n  vec3 x2 = x0 - i2 + C.yyy;\r\n  vec3 x3 = x0 - D.yyy;\r\n \r\n  i = mod289(i);\r\n  vec4 p = permute( permute( permute(\r\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\r\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\r\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\r\n \r\n  float n_ = 0.142857142857; // 1.0/7.0\r\n  vec3  ns = n_ * D.wyz - D.xzx;\r\n \r\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\r\n \r\n  vec4 x_ = floor(j * ns.z);\r\n  vec4 y_ = floor(j - 7.0 * x_ );\r\n \r\n  vec4 x = x_ *ns.x + ns.yyyy;\r\n  vec4 y = y_ *ns.x + ns.yyyy;\r\n  vec4 h = 1.0 - abs(x) - abs(y);\r\n \r\n  vec4 b0 = vec4( x.xy, y.xy );\r\n  vec4 b1 = vec4( x.zw, y.zw );\r\n \r\n  vec4 s0 = floor(b0)*2.0 + 1.0;\r\n  vec4 s1 = floor(b1)*2.0 + 1.0;\r\n  vec4 sh = -step(h, vec4(0.0));\r\n \r\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\r\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\r\n \r\n  vec3 p0 = vec3(a0.xy,h.x);\r\n  vec3 p1 = vec3(a0.zw,h.y);\r\n  vec3 p2 = vec3(a1.xy,h.z);\r\n  vec3 p3 = vec3(a1.zw,h.w);\r\n \r\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\r\n  p0 *= norm.x;\r\n  p1 *= norm.y;\r\n  p2 *= norm.z;\r\n  p3 *= norm.w;\r\n \r\n  vec4 values = vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ); //value of contributions from each corner (extrapolate the gradient)\r\n \r\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0); //kernel function from each corner\r\n \r\n  vec4 m2 = m * m;\r\n  vec4 m3 = m * m * m;\r\n \r\n  vec4 temp = -6.0 * m2 * values;\r\n  float dx = temp[0] * x0.x + temp[1] * x1.x + temp[2] * x2.x + temp[3] * x3.x + m3[0] * p0.x + m3[1] * p1.x + m3[2] * p2.x + m3[3] * p3.x;\r\n  float dy = temp[0] * x0.y + temp[1] * x1.y + temp[2] * x2.y + temp[3] * x3.y + m3[0] * p0.y + m3[1] * p1.y + m3[2] * p2.y + m3[3] * p3.y;\r\n  float dz = temp[0] * x0.z + temp[1] * x1.z + temp[2] * x2.z + temp[3] * x3.z + m3[0] * p0.z + m3[1] * p1.z + m3[2] * p2.z + m3[3] * p3.z;\r\n \r\n  return vec4(dot(m3, values), dx, dy, dz) * 42.0;\r\n}\r\n\r\n\r\nvec3 curlNoise3 (vec3 p) {\r\n\r\n    vec3 xNoisePotentialDerivatives = snoiseD( p ).yzw; //yzw are the xyz derivatives\r\n    vec3 yNoisePotentialDerivatives = snoiseD(vec3( p.y - 19.1 , p.z + 33.4 , p.x + 47.2 )).zwy;\r\n    vec3 zNoisePotentialDerivatives = snoiseD(vec3( p.z + 74.2 , p.x - 124.5 , p.y + 99.4 )).wyz;\r\n    vec3 noiseVelocity = vec3(\r\n        zNoisePotentialDerivatives.y - yNoisePotentialDerivatives.z,\r\n        xNoisePotentialDerivatives.z - zNoisePotentialDerivatives.x,\r\n        yNoisePotentialDerivatives.x - xNoisePotentialDerivatives.y\r\n    );\r\n\t\r\n\tconst float e = .1;\r\n\tconst float divisor = 1.0 / ( 2.0 * e );\r\n\treturn normalize( noiseVelocity * divisor );\r\n\r\n}\r\n\t\r\n\t" + "\r\n\t\r\n\t\t#define PHONG\r\n\r\n\t\tuniform vec3 diffuse;\r\n\t\tuniform vec3 emissive;\r\n\t\tuniform vec3 specular;\r\n\t\tuniform float shininess;\r\n\t\tuniform float opacity;\r\n\r\n\t\tvarying float counter;\r\n\t\t\r\n\t\t#include <common>\r\n\t\t#include <packing>\r\n\t\t#include <dithering_pars_fragment>\r\n\t\t#include <color_pars_fragment>\r\n\t\t#include <uv_pars_fragment>\r\n\t\t#include <uv2_pars_fragment>\r\n\t\t#include <map_pars_fragment>\r\n\t\t#include <alphamap_pars_fragment>\r\n\t\t#include <aomap_pars_fragment>\r\n\t\t#include <lightmap_pars_fragment>\r\n\t\t#include <emissivemap_pars_fragment>\r\n\t\t#include <envmap_pars_fragment>\r\n\t\t#include <gradientmap_pars_fragment>\r\n\t\t#include <fog_pars_fragment>\r\n\t\t#include <bsdfs>\r\n\t\t#include <lights_pars>\r\n\t\t#include <lights_phong_pars_fragment>\r\n\t\t#include <shadowmap_pars_fragment>\r\n\t\t#include <bumpmap_pars_fragment>\r\n\t\t#include <normalmap_pars_fragment>\r\n\t\t#include <specularmap_pars_fragment>\r\n\t\t#include <logdepthbuf_pars_fragment>\r\n\t\t#include <clipping_planes_pars_fragment>\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\t#include <clipping_planes_fragment>\r\n\r\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\t\t\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\t\t\tvec3 totalEmissiveRadiance = emissive;\r\n\t\t\t\r\n\t\t\tdiffuseColor.xyz = snoiseVec3( vViewPosition * 0.01 + counter);\r\n\t\t\tdiffuseColor.x = abs( diffuseColor.z + 0.5 );\r\n\t\t\tdiffuseColor.y = abs( 0.6 * diffuseColor.y + 0.2 );\r\n\t\t\tdiffuseColor.z = abs( 0.1 * diffuseColor.z + 0.2 );\r\n\t\t\t\r\n\t\t\t#include <logdepthbuf_fragment>\r\n\t\t\t#include <map_fragment>\r\n\t\t\t#include <color_fragment>\r\n\t\t\t#include <alphamap_fragment>\r\n\t\t\t#include <alphatest_fragment>\r\n\t\t\t#include <specularmap_fragment>\r\n\t\t\t#include <normal_fragment>\r\n\t\t\t#include <emissivemap_fragment>\r\n\r\n\t\t\t// accumulation\r\n\t\t\t#include <lights_phong_fragment>\r\n\t\t\t#include <lights_template>\r\n\r\n\t\t\t// modulation\r\n\t\t\t#include <aomap_fragment>\r\n\r\n\t\t\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n\r\n\t\t\t#include <envmap_fragment>\r\n\r\n\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t\t\t#include <tonemapping_fragment>\r\n\t\t\t#include <encodings_fragment>\r\n\t\t\t#include <fog_fragment>\r\n\t\t\t#include <premultiplied_alpha_fragment>\r\n\t\t\t#include <dithering_fragment>\r\n\r\n\t\t}\r\n\t\r\n\t";
	this.vv = "\r\n//\r\n// Description : Array and textureless GLSL 2D/3D/4D simplex \r\n//               noise functions.\r\n//      Author : Ian McEwan, Ashima Arts.\r\n//  Maintainer : ijm\r\n//     Lastmod : 20110822 (ijm)\r\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\r\n//               Distributed under the MIT License. See LICENSE file.\r\n//               https://github.com/ashima/webgl-noise\r\n// \r\n\r\nvec3 mod289(vec3 x) {\r\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec4 mod289(vec4 x) {\r\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec4 permute(vec4 x) {\r\n\treturn mod289(((x*34.0)+1.0)*x);\r\n}\r\n\r\nvec4 taylorInvSqrt(vec4 r){\r\n\treturn 1.79284291400159 - 0.85373472095314 * r;\r\n}\r\n\r\nfloat snoise(vec3 v) { \r\n\r\n\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\r\n\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\r\n\r\n\t// First corner\r\n\tvec3 i  = floor(v + dot(v, C.yyy) );\r\n\tvec3 x0 =   v - i + dot(i, C.xxx) ;\r\n\r\n\t// Other corners\r\n\tvec3 g = step(x0.yzx, x0.xyz);\r\n\tvec3 l = 1.0 - g;\r\n\tvec3 i1 = min( g.xyz, l.zxy );\r\n\tvec3 i2 = max( g.xyz, l.zxy );\r\n\r\n\t//   x0 = x0 - 0.0 + 0.0 * C.xxx;\r\n\t//   x1 = x0 - i1  + 1.0 * C.xxx;\r\n\t//   x2 = x0 - i2  + 2.0 * C.xxx;\r\n\t//   x3 = x0 - 1.0 + 3.0 * C.xxx;\r\n\tvec3 x1 = x0 - i1 + C.xxx;\r\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\r\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\r\n\r\n\t// Permutations\r\n\ti = mod289(i); \r\n\tvec4 p = permute( permute( permute( \r\n\t\t  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\r\n\t\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \r\n\t\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\r\n\r\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\r\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\r\n\tfloat n_ = 0.142857142857; // 1.0/7.0\r\n\tvec3  ns = n_ * D.wyz - D.xzx;\r\n\r\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\r\n\r\n\tvec4 x_ = floor(j * ns.z);\r\n\tvec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\r\n\r\n\tvec4 x = x_ *ns.x + ns.yyyy;\r\n\tvec4 y = y_ *ns.x + ns.yyyy;\r\n\tvec4 h = 1.0 - abs(x) - abs(y);\r\n\r\n\tvec4 b0 = vec4( x.xy, y.xy );\r\n\tvec4 b1 = vec4( x.zw, y.zw );\r\n\r\n\t//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\r\n\t//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\r\n\tvec4 s0 = floor(b0)*2.0 + 1.0;\r\n\tvec4 s1 = floor(b1)*2.0 + 1.0;\r\n\tvec4 sh = -step(h, vec4(0.0));\r\n\r\n\tvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\r\n\tvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\r\n\r\n\tvec3 p0 = vec3(a0.xy,h.x);\r\n\tvec3 p1 = vec3(a0.zw,h.y);\r\n\tvec3 p2 = vec3(a1.xy,h.z);\r\n\tvec3 p3 = vec3(a1.zw,h.w);\r\n\r\n\t//Normalise gradients\r\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\r\n\tp0 *= norm.x;\r\n\tp1 *= norm.y;\r\n\tp2 *= norm.z;\r\n\tp3 *= norm.w;\r\n\r\n\t// Mix final noise value\r\n\tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\r\n\tm = m * m;\r\n\treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\r\n\r\n}\r\n\r\nvec3 snoiseVec3( vec3 x ){\r\n\r\n\tfloat s  = snoise(vec3( x ));\r\n\tfloat s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\r\n\tfloat s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\r\n\tvec3 c = vec3( s , s1 , s2 );\r\n\treturn c;\r\n\r\n}\r\n\r\nvec3 snoiseVec3Abs( vec3 x ){\r\n\r\n\tfloat s  = snoise(vec3( x ));\r\n\tfloat s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\r\n\tfloat s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\r\n\tvec3 c = vec3( abs(s) , abs(s1) , abs(s2) );\r\n\treturn c;\r\n\r\n}\r\n\r\n\r\nvec3 curlNoise( vec3 p ){\r\n \r\n\tconst float e = .1;\r\n\tvec3 dx = vec3( e   , 0.0 , 0.0 );\r\n\tvec3 dy = vec3( 0.0 , e   , 0.0 );\r\n\tvec3 dz = vec3( 0.0 , 0.0 , e   );\r\n\r\n\tvec3 p_x0 = snoiseVec3( p - dx );\r\n\tvec3 p_x1 = snoiseVec3( p + dx );\r\n\tvec3 p_y0 = snoiseVec3( p - dy );\r\n\tvec3 p_y1 = snoiseVec3( p + dy );\r\n\tvec3 p_z0 = snoiseVec3( p - dz );\r\n\tvec3 p_z1 = snoiseVec3( p + dz );\r\n\r\n\tfloat x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\r\n\tfloat y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\r\n\tfloat z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\r\n\r\n\tconst float divisor = 1.0 / ( 2.0 * e );\r\n\treturn normalize( vec3( x , y , z ) * divisor );\r\n\r\n}\r\n\r\nvec3 curlNoise2( vec3 p ) {\r\n\r\n\tconst float e = .1;\r\n\r\n\tvec3 xNoisePotentialDerivatives = snoiseVec3( p );\r\n\tvec3 yNoisePotentialDerivatives = snoiseVec3( p + e * vec3( 3., -3.,  1. ) );\r\n\tvec3 zNoisePotentialDerivatives = snoiseVec3( p + e * vec3( 2.,  4., -3. ) );\r\n\r\n\tvec3 noiseVelocity = vec3(\r\n\t\tzNoisePotentialDerivatives.y - yNoisePotentialDerivatives.z,\r\n\t\txNoisePotentialDerivatives.z - zNoisePotentialDerivatives.x,\r\n\t\tyNoisePotentialDerivatives.x - xNoisePotentialDerivatives.y\r\n\t);\r\n\r\n\treturn normalize( noiseVelocity );\r\n\r\n}\r\n\r\nvec4 snoiseD(vec3 v) { //returns vec4(value, dx, dy, dz)\r\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\r\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\r\n \r\n  vec3 i  = floor(v + dot(v, C.yyy) );\r\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\r\n \r\n  vec3 g = step(x0.yzx, x0.xyz);\r\n  vec3 l = 1.0 - g;\r\n  vec3 i1 = min( g.xyz, l.zxy );\r\n  vec3 i2 = max( g.xyz, l.zxy );\r\n \r\n  vec3 x1 = x0 - i1 + C.xxx;\r\n  vec3 x2 = x0 - i2 + C.yyy;\r\n  vec3 x3 = x0 - D.yyy;\r\n \r\n  i = mod289(i);\r\n  vec4 p = permute( permute( permute(\r\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\r\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\r\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\r\n \r\n  float n_ = 0.142857142857; // 1.0/7.0\r\n  vec3  ns = n_ * D.wyz - D.xzx;\r\n \r\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\r\n \r\n  vec4 x_ = floor(j * ns.z);\r\n  vec4 y_ = floor(j - 7.0 * x_ );\r\n \r\n  vec4 x = x_ *ns.x + ns.yyyy;\r\n  vec4 y = y_ *ns.x + ns.yyyy;\r\n  vec4 h = 1.0 - abs(x) - abs(y);\r\n \r\n  vec4 b0 = vec4( x.xy, y.xy );\r\n  vec4 b1 = vec4( x.zw, y.zw );\r\n \r\n  vec4 s0 = floor(b0)*2.0 + 1.0;\r\n  vec4 s1 = floor(b1)*2.0 + 1.0;\r\n  vec4 sh = -step(h, vec4(0.0));\r\n \r\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\r\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\r\n \r\n  vec3 p0 = vec3(a0.xy,h.x);\r\n  vec3 p1 = vec3(a0.zw,h.y);\r\n  vec3 p2 = vec3(a1.xy,h.z);\r\n  vec3 p3 = vec3(a1.zw,h.w);\r\n \r\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\r\n  p0 *= norm.x;\r\n  p1 *= norm.y;\r\n  p2 *= norm.z;\r\n  p3 *= norm.w;\r\n \r\n  vec4 values = vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ); //value of contributions from each corner (extrapolate the gradient)\r\n \r\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0); //kernel function from each corner\r\n \r\n  vec4 m2 = m * m;\r\n  vec4 m3 = m * m * m;\r\n \r\n  vec4 temp = -6.0 * m2 * values;\r\n  float dx = temp[0] * x0.x + temp[1] * x1.x + temp[2] * x2.x + temp[3] * x3.x + m3[0] * p0.x + m3[1] * p1.x + m3[2] * p2.x + m3[3] * p3.x;\r\n  float dy = temp[0] * x0.y + temp[1] * x1.y + temp[2] * x2.y + temp[3] * x3.y + m3[0] * p0.y + m3[1] * p1.y + m3[2] * p2.y + m3[3] * p3.y;\r\n  float dz = temp[0] * x0.z + temp[1] * x1.z + temp[2] * x2.z + temp[3] * x3.z + m3[0] * p0.z + m3[1] * p1.z + m3[2] * p2.z + m3[3] * p3.z;\r\n \r\n  return vec4(dot(m3, values), dx, dy, dz) * 42.0;\r\n}\r\n\r\n\r\nvec3 curlNoise3 (vec3 p) {\r\n\r\n    vec3 xNoisePotentialDerivatives = snoiseD( p ).yzw; //yzw are the xyz derivatives\r\n    vec3 yNoisePotentialDerivatives = snoiseD(vec3( p.y - 19.1 , p.z + 33.4 , p.x + 47.2 )).zwy;\r\n    vec3 zNoisePotentialDerivatives = snoiseD(vec3( p.z + 74.2 , p.x - 124.5 , p.y + 99.4 )).wyz;\r\n    vec3 noiseVelocity = vec3(\r\n        zNoisePotentialDerivatives.y - yNoisePotentialDerivatives.z,\r\n        xNoisePotentialDerivatives.z - zNoisePotentialDerivatives.x,\r\n        yNoisePotentialDerivatives.x - xNoisePotentialDerivatives.y\r\n    );\r\n\t\r\n\tconst float e = .1;\r\n\tconst float divisor = 1.0 / ( 2.0 * e );\r\n\treturn normalize( noiseVelocity * divisor );\r\n\r\n}\r\n\t\r\n\t" + "\r\n\t\t#define PHONG\r\n\r\n\t\tvarying vec3 vViewPosition;\r\n\t\tvarying float counter;\r\n\t\t\r\n\t\t#ifndef FLAT_SHADED\r\n\r\n\t\t\tvarying vec3 vNormal;\r\n\r\n\t\t#endif\r\n\r\n\t\t#include <common>\r\n\t\t#include <uv_pars_vertex>\r\n\t\t#include <uv2_pars_vertex>\r\n\t\t#include <displacementmap_pars_vertex>\r\n\t\t#include <envmap_pars_vertex>\r\n\t\t#include <color_pars_vertex>\r\n\t\t#include <fog_pars_vertex>\r\n\t\t#include <morphtarget_pars_vertex>\r\n\t\t#include <skinning_pars_vertex>\r\n\t\t#include <shadowmap_pars_vertex>\r\n\t\t#include <logdepthbuf_pars_vertex>\r\n\t\t#include <clipping_planes_pars_vertex>\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\t#include <uv_vertex>\r\n\t\t\t#include <uv2_vertex>\r\n\t\t\t#include <color_vertex>\r\n\r\n\t\t\t#include <beginnormal_vertex>\r\n\t\t\t#include <morphnormal_vertex>\r\n\t\t\t#include <skinbase_vertex>\r\n\t\t\t#include <skinnormal_vertex>\r\n\t\t\t#include <defaultnormal_vertex>\r\n\r\n\t\t#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\t\t\tvNormal = normalize( transformedNormal );\r\n\r\n\t\t#endif\r\n\r\n\t\t\t#include <begin_vertex>\r\n\t\t\t#include <morphtarget_vertex>\r\n\t\t\t#include <skinning_vertex>\r\n\t\t\t#include <displacementmap_vertex>\r\n\t\t\t#include <project_vertex>\r\n\t\t\t#include <logdepthbuf_vertex>\r\n\t\t\t#include <clipping_planes_vertex>\r\n\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\r\n\t\t\t#include <worldpos_vertex>\r\n\t\t\t#include <envmap_vertex>\r\n\t\t\t#include <shadowmap_vertex>\r\n\t\t\t#include <fog_vertex>\r\n\r\n\t\t}\t\r\n\t";
	var phongShader = THREE.ShaderLib.phong;
	var unif = THREE.UniformsUtils .clone(phongShader.uniforms);
	unif.counter = { type : "f", value : 10000 * Math.random()};
	unif.specular.value = new THREE.Color(8947848);
	unif.emissive.value = new THREE.Color(2236962);
	THREE.ShaderMaterial.call(this,{ uniforms : unif, vertexShader : this.vv, fragmentShader : this.ff, lights : true});
	this.vertexColors = false;
	this.shading = 1;
	this.side = 0;
};
mat_MyShaderMat.__super__ = THREE.ShaderMaterial;
mat_MyShaderMat.prototype = $extend(THREE.ShaderMaterial.prototype,{
	update: function() {
		this.uniforms.counter.value += 0.001;
	}
});
var mat_MyShaderMat2 = function(deform) {
	if(deform == null) {
		deform = 1;
	}
	this.ff = "\r\n//\r\n// Description : Array and textureless GLSL 2D/3D/4D simplex \r\n//               noise functions.\r\n//      Author : Ian McEwan, Ashima Arts.\r\n//  Maintainer : ijm\r\n//     Lastmod : 20110822 (ijm)\r\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\r\n//               Distributed under the MIT License. See LICENSE file.\r\n//               https://github.com/ashima/webgl-noise\r\n// \r\n\r\nvec3 mod289(vec3 x) {\r\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec4 mod289(vec4 x) {\r\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec4 permute(vec4 x) {\r\n\treturn mod289(((x*34.0)+1.0)*x);\r\n}\r\n\r\nvec4 taylorInvSqrt(vec4 r){\r\n\treturn 1.79284291400159 - 0.85373472095314 * r;\r\n}\r\n\r\nfloat snoise(vec3 v) { \r\n\r\n\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\r\n\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\r\n\r\n\t// First corner\r\n\tvec3 i  = floor(v + dot(v, C.yyy) );\r\n\tvec3 x0 =   v - i + dot(i, C.xxx) ;\r\n\r\n\t// Other corners\r\n\tvec3 g = step(x0.yzx, x0.xyz);\r\n\tvec3 l = 1.0 - g;\r\n\tvec3 i1 = min( g.xyz, l.zxy );\r\n\tvec3 i2 = max( g.xyz, l.zxy );\r\n\r\n\t//   x0 = x0 - 0.0 + 0.0 * C.xxx;\r\n\t//   x1 = x0 - i1  + 1.0 * C.xxx;\r\n\t//   x2 = x0 - i2  + 2.0 * C.xxx;\r\n\t//   x3 = x0 - 1.0 + 3.0 * C.xxx;\r\n\tvec3 x1 = x0 - i1 + C.xxx;\r\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\r\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\r\n\r\n\t// Permutations\r\n\ti = mod289(i); \r\n\tvec4 p = permute( permute( permute( \r\n\t\t  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\r\n\t\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \r\n\t\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\r\n\r\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\r\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\r\n\tfloat n_ = 0.142857142857; // 1.0/7.0\r\n\tvec3  ns = n_ * D.wyz - D.xzx;\r\n\r\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\r\n\r\n\tvec4 x_ = floor(j * ns.z);\r\n\tvec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\r\n\r\n\tvec4 x = x_ *ns.x + ns.yyyy;\r\n\tvec4 y = y_ *ns.x + ns.yyyy;\r\n\tvec4 h = 1.0 - abs(x) - abs(y);\r\n\r\n\tvec4 b0 = vec4( x.xy, y.xy );\r\n\tvec4 b1 = vec4( x.zw, y.zw );\r\n\r\n\t//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\r\n\t//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\r\n\tvec4 s0 = floor(b0)*2.0 + 1.0;\r\n\tvec4 s1 = floor(b1)*2.0 + 1.0;\r\n\tvec4 sh = -step(h, vec4(0.0));\r\n\r\n\tvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\r\n\tvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\r\n\r\n\tvec3 p0 = vec3(a0.xy,h.x);\r\n\tvec3 p1 = vec3(a0.zw,h.y);\r\n\tvec3 p2 = vec3(a1.xy,h.z);\r\n\tvec3 p3 = vec3(a1.zw,h.w);\r\n\r\n\t//Normalise gradients\r\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\r\n\tp0 *= norm.x;\r\n\tp1 *= norm.y;\r\n\tp2 *= norm.z;\r\n\tp3 *= norm.w;\r\n\r\n\t// Mix final noise value\r\n\tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\r\n\tm = m * m;\r\n\treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\r\n\r\n}\r\n\r\nvec3 snoiseVec3( vec3 x ){\r\n\r\n\tfloat s  = snoise(vec3( x ));\r\n\tfloat s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\r\n\tfloat s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\r\n\tvec3 c = vec3( s , s1 , s2 );\r\n\treturn c;\r\n\r\n}\r\n\r\nvec3 snoiseVec3Abs( vec3 x ){\r\n\r\n\tfloat s  = snoise(vec3( x ));\r\n\tfloat s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\r\n\tfloat s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\r\n\tvec3 c = vec3( abs(s) , abs(s1) , abs(s2) );\r\n\treturn c;\r\n\r\n}\r\n\r\n\r\nvec3 curlNoise( vec3 p ){\r\n \r\n\tconst float e = .1;\r\n\tvec3 dx = vec3( e   , 0.0 , 0.0 );\r\n\tvec3 dy = vec3( 0.0 , e   , 0.0 );\r\n\tvec3 dz = vec3( 0.0 , 0.0 , e   );\r\n\r\n\tvec3 p_x0 = snoiseVec3( p - dx );\r\n\tvec3 p_x1 = snoiseVec3( p + dx );\r\n\tvec3 p_y0 = snoiseVec3( p - dy );\r\n\tvec3 p_y1 = snoiseVec3( p + dy );\r\n\tvec3 p_z0 = snoiseVec3( p - dz );\r\n\tvec3 p_z1 = snoiseVec3( p + dz );\r\n\r\n\tfloat x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\r\n\tfloat y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\r\n\tfloat z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\r\n\r\n\tconst float divisor = 1.0 / ( 2.0 * e );\r\n\treturn normalize( vec3( x , y , z ) * divisor );\r\n\r\n}\r\n\r\nvec3 curlNoise2( vec3 p ) {\r\n\r\n\tconst float e = .1;\r\n\r\n\tvec3 xNoisePotentialDerivatives = snoiseVec3( p );\r\n\tvec3 yNoisePotentialDerivatives = snoiseVec3( p + e * vec3( 3., -3.,  1. ) );\r\n\tvec3 zNoisePotentialDerivatives = snoiseVec3( p + e * vec3( 2.,  4., -3. ) );\r\n\r\n\tvec3 noiseVelocity = vec3(\r\n\t\tzNoisePotentialDerivatives.y - yNoisePotentialDerivatives.z,\r\n\t\txNoisePotentialDerivatives.z - zNoisePotentialDerivatives.x,\r\n\t\tyNoisePotentialDerivatives.x - xNoisePotentialDerivatives.y\r\n\t);\r\n\r\n\treturn normalize( noiseVelocity );\r\n\r\n}\r\n\r\nvec4 snoiseD(vec3 v) { //returns vec4(value, dx, dy, dz)\r\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\r\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\r\n \r\n  vec3 i  = floor(v + dot(v, C.yyy) );\r\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\r\n \r\n  vec3 g = step(x0.yzx, x0.xyz);\r\n  vec3 l = 1.0 - g;\r\n  vec3 i1 = min( g.xyz, l.zxy );\r\n  vec3 i2 = max( g.xyz, l.zxy );\r\n \r\n  vec3 x1 = x0 - i1 + C.xxx;\r\n  vec3 x2 = x0 - i2 + C.yyy;\r\n  vec3 x3 = x0 - D.yyy;\r\n \r\n  i = mod289(i);\r\n  vec4 p = permute( permute( permute(\r\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\r\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\r\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\r\n \r\n  float n_ = 0.142857142857; // 1.0/7.0\r\n  vec3  ns = n_ * D.wyz - D.xzx;\r\n \r\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\r\n \r\n  vec4 x_ = floor(j * ns.z);\r\n  vec4 y_ = floor(j - 7.0 * x_ );\r\n \r\n  vec4 x = x_ *ns.x + ns.yyyy;\r\n  vec4 y = y_ *ns.x + ns.yyyy;\r\n  vec4 h = 1.0 - abs(x) - abs(y);\r\n \r\n  vec4 b0 = vec4( x.xy, y.xy );\r\n  vec4 b1 = vec4( x.zw, y.zw );\r\n \r\n  vec4 s0 = floor(b0)*2.0 + 1.0;\r\n  vec4 s1 = floor(b1)*2.0 + 1.0;\r\n  vec4 sh = -step(h, vec4(0.0));\r\n \r\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\r\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\r\n \r\n  vec3 p0 = vec3(a0.xy,h.x);\r\n  vec3 p1 = vec3(a0.zw,h.y);\r\n  vec3 p2 = vec3(a1.xy,h.z);\r\n  vec3 p3 = vec3(a1.zw,h.w);\r\n \r\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\r\n  p0 *= norm.x;\r\n  p1 *= norm.y;\r\n  p2 *= norm.z;\r\n  p3 *= norm.w;\r\n \r\n  vec4 values = vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ); //value of contributions from each corner (extrapolate the gradient)\r\n \r\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0); //kernel function from each corner\r\n \r\n  vec4 m2 = m * m;\r\n  vec4 m3 = m * m * m;\r\n \r\n  vec4 temp = -6.0 * m2 * values;\r\n  float dx = temp[0] * x0.x + temp[1] * x1.x + temp[2] * x2.x + temp[3] * x3.x + m3[0] * p0.x + m3[1] * p1.x + m3[2] * p2.x + m3[3] * p3.x;\r\n  float dy = temp[0] * x0.y + temp[1] * x1.y + temp[2] * x2.y + temp[3] * x3.y + m3[0] * p0.y + m3[1] * p1.y + m3[2] * p2.y + m3[3] * p3.y;\r\n  float dz = temp[0] * x0.z + temp[1] * x1.z + temp[2] * x2.z + temp[3] * x3.z + m3[0] * p0.z + m3[1] * p1.z + m3[2] * p2.z + m3[3] * p3.z;\r\n \r\n  return vec4(dot(m3, values), dx, dy, dz) * 42.0;\r\n}\r\n\r\n\r\nvec3 curlNoise3 (vec3 p) {\r\n\r\n    vec3 xNoisePotentialDerivatives = snoiseD( p ).yzw; //yzw are the xyz derivatives\r\n    vec3 yNoisePotentialDerivatives = snoiseD(vec3( p.y - 19.1 , p.z + 33.4 , p.x + 47.2 )).zwy;\r\n    vec3 zNoisePotentialDerivatives = snoiseD(vec3( p.z + 74.2 , p.x - 124.5 , p.y + 99.4 )).wyz;\r\n    vec3 noiseVelocity = vec3(\r\n        zNoisePotentialDerivatives.y - yNoisePotentialDerivatives.z,\r\n        xNoisePotentialDerivatives.z - zNoisePotentialDerivatives.x,\r\n        yNoisePotentialDerivatives.x - xNoisePotentialDerivatives.y\r\n    );\r\n\t\r\n\tconst float e = .1;\r\n\tconst float divisor = 1.0 / ( 2.0 * e );\r\n\treturn normalize( noiseVelocity * divisor );\r\n\r\n}\r\n\t\r\n\t" + "\r\n\t\r\n\t\t#define PHONG\r\n\r\n\t\tuniform vec3 diffuse;\r\n\t\tuniform vec3 emissive;\r\n\t\tuniform vec3 specular;\r\n\t\tuniform float shininess;\r\n\t\tuniform float opacity;\r\n\r\n\t\tvarying float counter;\r\n\t\t\r\n\t\t#include <common>\r\n\t\t#include <packing>\r\n\t\t#include <dithering_pars_fragment>\r\n\t\t#include <color_pars_fragment>\r\n\t\t#include <uv_pars_fragment>\r\n\t\t#include <uv2_pars_fragment>\r\n\t\t#include <map_pars_fragment>\r\n\t\t#include <alphamap_pars_fragment>\r\n\t\t#include <aomap_pars_fragment>\r\n\t\t#include <lightmap_pars_fragment>\r\n\t\t#include <emissivemap_pars_fragment>\r\n\t\t#include <envmap_pars_fragment>\r\n\t\t#include <gradientmap_pars_fragment>\r\n\t\t#include <fog_pars_fragment>\r\n\t\t#include <bsdfs>\r\n\t\t#include <lights_pars>\r\n\t\t#include <lights_phong_pars_fragment>\r\n\t\t#include <shadowmap_pars_fragment>\r\n\t\t#include <bumpmap_pars_fragment>\r\n\t\t#include <normalmap_pars_fragment>\r\n\t\t#include <specularmap_pars_fragment>\r\n\t\t#include <logdepthbuf_pars_fragment>\r\n\t\t#include <clipping_planes_pars_fragment>\r\n\r\n\t\t\t\t\tvec3 rgb2hsv(vec3 c)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\r\n\t\t\t\t\t\tvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\r\n\t\t\t\t\t\tvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\r\n\r\n\t\t\t\t\t\tfloat d = q.x - min(q.w, q.y);\r\n\t\t\t\t\t\tfloat e = 1.0e-10;\r\n\t\t\t\t\t\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tvec3 hsv2rgb(vec3 c)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\n\t\t\t\t\t\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\r\n\t\t\t\t\t\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\r\n\t\t\t\t\t}\t\t\r\n\t\t\r\n\t\t\t\t\t\r\n\t\tvoid main() {\r\n\r\n\t\t\t#include <clipping_planes_fragment>\r\n\r\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\t\t\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\t\t\tvec3 totalEmissiveRadiance = emissive;\r\n\t\t\t\r\n\t\t\tdiffuseColor.xyz = snoiseVec3( vViewPosition * 0.001 + counter);\r\n\t\t\tdiffuseColor.x = diffuseColor.x + 1.5;\r\n\t\t\tdiffuseColor.y = diffuseColor.x;// diffuseColor.y * 0.3 + 0.2 + diffuseColor.x;\r\n\t\t\tdiffuseColor.z = diffuseColor.x;// diffuseColor.z * 0.3 + 0.1 + diffuseColor.x;\r\n\t\t\t\r\n\t\t\t//diffuseColor.xyz += 0.2 * snoiseVec3( vViewPosition * 10.001 + counter);\r\n\t\t\t\r\n\t\t\t#include <logdepthbuf_fragment>\r\n\t\t\t#include <map_fragment>\r\n\t\t\t#include <color_fragment>\r\n\t\t\t#include <alphamap_fragment>\r\n\t\t\t#include <alphatest_fragment>\r\n\t\t\t#include <specularmap_fragment>\r\n\t\t\t#include <normal_fragment>\r\n\t\t\t#include <emissivemap_fragment>\r\n\r\n\t\t\t// accumulation\r\n\t\t\t#include <lights_phong_fragment>\r\n\t\t\t#include <lights_template>\r\n\r\n\t\t\t// modulation\r\n\t\t\t#include <aomap_fragment>\r\n\r\n\t\t\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n\r\n\t\t\t#include <envmap_fragment>\r\n\r\n\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t\t\t#include <tonemapping_fragment>\r\n\t\t\t#include <encodings_fragment>\r\n\t\t\t#include <fog_fragment>\r\n\t\t\t#include <premultiplied_alpha_fragment>\r\n\t\t\t#include <dithering_fragment>\r\n\r\n\t\t}\r\n\t\r\n\t";
	this.vv = "\r\n//\r\n// Description : Array and textureless GLSL 2D/3D/4D simplex \r\n//               noise functions.\r\n//      Author : Ian McEwan, Ashima Arts.\r\n//  Maintainer : ijm\r\n//     Lastmod : 20110822 (ijm)\r\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\r\n//               Distributed under the MIT License. See LICENSE file.\r\n//               https://github.com/ashima/webgl-noise\r\n// \r\n\r\nvec3 mod289(vec3 x) {\r\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec4 mod289(vec4 x) {\r\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec4 permute(vec4 x) {\r\n\treturn mod289(((x*34.0)+1.0)*x);\r\n}\r\n\r\nvec4 taylorInvSqrt(vec4 r){\r\n\treturn 1.79284291400159 - 0.85373472095314 * r;\r\n}\r\n\r\nfloat snoise(vec3 v) { \r\n\r\n\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\r\n\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\r\n\r\n\t// First corner\r\n\tvec3 i  = floor(v + dot(v, C.yyy) );\r\n\tvec3 x0 =   v - i + dot(i, C.xxx) ;\r\n\r\n\t// Other corners\r\n\tvec3 g = step(x0.yzx, x0.xyz);\r\n\tvec3 l = 1.0 - g;\r\n\tvec3 i1 = min( g.xyz, l.zxy );\r\n\tvec3 i2 = max( g.xyz, l.zxy );\r\n\r\n\t//   x0 = x0 - 0.0 + 0.0 * C.xxx;\r\n\t//   x1 = x0 - i1  + 1.0 * C.xxx;\r\n\t//   x2 = x0 - i2  + 2.0 * C.xxx;\r\n\t//   x3 = x0 - 1.0 + 3.0 * C.xxx;\r\n\tvec3 x1 = x0 - i1 + C.xxx;\r\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\r\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\r\n\r\n\t// Permutations\r\n\ti = mod289(i); \r\n\tvec4 p = permute( permute( permute( \r\n\t\t  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\r\n\t\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \r\n\t\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\r\n\r\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\r\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\r\n\tfloat n_ = 0.142857142857; // 1.0/7.0\r\n\tvec3  ns = n_ * D.wyz - D.xzx;\r\n\r\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\r\n\r\n\tvec4 x_ = floor(j * ns.z);\r\n\tvec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\r\n\r\n\tvec4 x = x_ *ns.x + ns.yyyy;\r\n\tvec4 y = y_ *ns.x + ns.yyyy;\r\n\tvec4 h = 1.0 - abs(x) - abs(y);\r\n\r\n\tvec4 b0 = vec4( x.xy, y.xy );\r\n\tvec4 b1 = vec4( x.zw, y.zw );\r\n\r\n\t//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\r\n\t//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\r\n\tvec4 s0 = floor(b0)*2.0 + 1.0;\r\n\tvec4 s1 = floor(b1)*2.0 + 1.0;\r\n\tvec4 sh = -step(h, vec4(0.0));\r\n\r\n\tvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\r\n\tvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\r\n\r\n\tvec3 p0 = vec3(a0.xy,h.x);\r\n\tvec3 p1 = vec3(a0.zw,h.y);\r\n\tvec3 p2 = vec3(a1.xy,h.z);\r\n\tvec3 p3 = vec3(a1.zw,h.w);\r\n\r\n\t//Normalise gradients\r\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\r\n\tp0 *= norm.x;\r\n\tp1 *= norm.y;\r\n\tp2 *= norm.z;\r\n\tp3 *= norm.w;\r\n\r\n\t// Mix final noise value\r\n\tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\r\n\tm = m * m;\r\n\treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\r\n\r\n}\r\n\r\nvec3 snoiseVec3( vec3 x ){\r\n\r\n\tfloat s  = snoise(vec3( x ));\r\n\tfloat s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\r\n\tfloat s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\r\n\tvec3 c = vec3( s , s1 , s2 );\r\n\treturn c;\r\n\r\n}\r\n\r\nvec3 snoiseVec3Abs( vec3 x ){\r\n\r\n\tfloat s  = snoise(vec3( x ));\r\n\tfloat s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\r\n\tfloat s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\r\n\tvec3 c = vec3( abs(s) , abs(s1) , abs(s2) );\r\n\treturn c;\r\n\r\n}\r\n\r\n\r\nvec3 curlNoise( vec3 p ){\r\n \r\n\tconst float e = .1;\r\n\tvec3 dx = vec3( e   , 0.0 , 0.0 );\r\n\tvec3 dy = vec3( 0.0 , e   , 0.0 );\r\n\tvec3 dz = vec3( 0.0 , 0.0 , e   );\r\n\r\n\tvec3 p_x0 = snoiseVec3( p - dx );\r\n\tvec3 p_x1 = snoiseVec3( p + dx );\r\n\tvec3 p_y0 = snoiseVec3( p - dy );\r\n\tvec3 p_y1 = snoiseVec3( p + dy );\r\n\tvec3 p_z0 = snoiseVec3( p - dz );\r\n\tvec3 p_z1 = snoiseVec3( p + dz );\r\n\r\n\tfloat x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\r\n\tfloat y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\r\n\tfloat z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\r\n\r\n\tconst float divisor = 1.0 / ( 2.0 * e );\r\n\treturn normalize( vec3( x , y , z ) * divisor );\r\n\r\n}\r\n\r\nvec3 curlNoise2( vec3 p ) {\r\n\r\n\tconst float e = .1;\r\n\r\n\tvec3 xNoisePotentialDerivatives = snoiseVec3( p );\r\n\tvec3 yNoisePotentialDerivatives = snoiseVec3( p + e * vec3( 3., -3.,  1. ) );\r\n\tvec3 zNoisePotentialDerivatives = snoiseVec3( p + e * vec3( 2.,  4., -3. ) );\r\n\r\n\tvec3 noiseVelocity = vec3(\r\n\t\tzNoisePotentialDerivatives.y - yNoisePotentialDerivatives.z,\r\n\t\txNoisePotentialDerivatives.z - zNoisePotentialDerivatives.x,\r\n\t\tyNoisePotentialDerivatives.x - xNoisePotentialDerivatives.y\r\n\t);\r\n\r\n\treturn normalize( noiseVelocity );\r\n\r\n}\r\n\r\nvec4 snoiseD(vec3 v) { //returns vec4(value, dx, dy, dz)\r\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\r\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\r\n \r\n  vec3 i  = floor(v + dot(v, C.yyy) );\r\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\r\n \r\n  vec3 g = step(x0.yzx, x0.xyz);\r\n  vec3 l = 1.0 - g;\r\n  vec3 i1 = min( g.xyz, l.zxy );\r\n  vec3 i2 = max( g.xyz, l.zxy );\r\n \r\n  vec3 x1 = x0 - i1 + C.xxx;\r\n  vec3 x2 = x0 - i2 + C.yyy;\r\n  vec3 x3 = x0 - D.yyy;\r\n \r\n  i = mod289(i);\r\n  vec4 p = permute( permute( permute(\r\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\r\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\r\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\r\n \r\n  float n_ = 0.142857142857; // 1.0/7.0\r\n  vec3  ns = n_ * D.wyz - D.xzx;\r\n \r\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\r\n \r\n  vec4 x_ = floor(j * ns.z);\r\n  vec4 y_ = floor(j - 7.0 * x_ );\r\n \r\n  vec4 x = x_ *ns.x + ns.yyyy;\r\n  vec4 y = y_ *ns.x + ns.yyyy;\r\n  vec4 h = 1.0 - abs(x) - abs(y);\r\n \r\n  vec4 b0 = vec4( x.xy, y.xy );\r\n  vec4 b1 = vec4( x.zw, y.zw );\r\n \r\n  vec4 s0 = floor(b0)*2.0 + 1.0;\r\n  vec4 s1 = floor(b1)*2.0 + 1.0;\r\n  vec4 sh = -step(h, vec4(0.0));\r\n \r\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\r\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\r\n \r\n  vec3 p0 = vec3(a0.xy,h.x);\r\n  vec3 p1 = vec3(a0.zw,h.y);\r\n  vec3 p2 = vec3(a1.xy,h.z);\r\n  vec3 p3 = vec3(a1.zw,h.w);\r\n \r\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\r\n  p0 *= norm.x;\r\n  p1 *= norm.y;\r\n  p2 *= norm.z;\r\n  p3 *= norm.w;\r\n \r\n  vec4 values = vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ); //value of contributions from each corner (extrapolate the gradient)\r\n \r\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0); //kernel function from each corner\r\n \r\n  vec4 m2 = m * m;\r\n  vec4 m3 = m * m * m;\r\n \r\n  vec4 temp = -6.0 * m2 * values;\r\n  float dx = temp[0] * x0.x + temp[1] * x1.x + temp[2] * x2.x + temp[3] * x3.x + m3[0] * p0.x + m3[1] * p1.x + m3[2] * p2.x + m3[3] * p3.x;\r\n  float dy = temp[0] * x0.y + temp[1] * x1.y + temp[2] * x2.y + temp[3] * x3.y + m3[0] * p0.y + m3[1] * p1.y + m3[2] * p2.y + m3[3] * p3.y;\r\n  float dz = temp[0] * x0.z + temp[1] * x1.z + temp[2] * x2.z + temp[3] * x3.z + m3[0] * p0.z + m3[1] * p1.z + m3[2] * p2.z + m3[3] * p3.z;\r\n \r\n  return vec4(dot(m3, values), dx, dy, dz) * 42.0;\r\n}\r\n\r\n\r\nvec3 curlNoise3 (vec3 p) {\r\n\r\n    vec3 xNoisePotentialDerivatives = snoiseD( p ).yzw; //yzw are the xyz derivatives\r\n    vec3 yNoisePotentialDerivatives = snoiseD(vec3( p.y - 19.1 , p.z + 33.4 , p.x + 47.2 )).zwy;\r\n    vec3 zNoisePotentialDerivatives = snoiseD(vec3( p.z + 74.2 , p.x - 124.5 , p.y + 99.4 )).wyz;\r\n    vec3 noiseVelocity = vec3(\r\n        zNoisePotentialDerivatives.y - yNoisePotentialDerivatives.z,\r\n        xNoisePotentialDerivatives.z - zNoisePotentialDerivatives.x,\r\n        yNoisePotentialDerivatives.x - xNoisePotentialDerivatives.y\r\n    );\r\n\t\r\n\tconst float e = .1;\r\n\tconst float divisor = 1.0 / ( 2.0 * e );\r\n\treturn normalize( noiseVelocity * divisor );\r\n\r\n}\r\n\t\r\n\t" + "\r\n\t\t#define PHONG\r\n\r\n\t\tvarying vec3 vViewPosition;\r\n\t\tvarying float counter;\r\n\t\t\r\n\t\t#ifndef FLAT_SHADED\r\n\r\n\t\t\tvarying vec3 vNormal;\r\n\r\n\t\t#endif\r\n\r\n\t\t#include <common>\r\n\t\t#include <uv_pars_vertex>\r\n\t\t#include <uv2_pars_vertex>\r\n\t\t#include <displacementmap_pars_vertex>\r\n\t\t#include <envmap_pars_vertex>\r\n\t\t#include <color_pars_vertex>\r\n\t\t#include <fog_pars_vertex>\r\n\t\t#include <morphtarget_pars_vertex>\r\n\t\t#include <skinning_pars_vertex>\r\n\t\t#include <shadowmap_pars_vertex>\r\n\t\t#include <logdepthbuf_pars_vertex>\r\n\t\t#include <clipping_planes_pars_vertex>\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\t#include <uv_vertex>\r\n\t\t\t#include <uv2_vertex>\r\n\t\t\t#include <color_vertex>\r\n\r\n\t\t\t#include <beginnormal_vertex>\r\n\t\t\t#include <morphnormal_vertex>\r\n\t\t\t#include <skinbase_vertex>\r\n\t\t\t#include <skinnormal_vertex>\r\n\t\t\t#include <defaultnormal_vertex>\r\n\r\n\t\t#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\t\t\tvNormal = normalize( transformedNormal );\r\n\r\n\t\t#endif\r\n\r\n\t\t\t#include <begin_vertex>\r\n\t\t\t#include <morphtarget_vertex>\r\n\t\t\t#include <skinning_vertex>\r\n\t\t\t#include <displacementmap_vertex>\r\n\t\t\t#include <project_vertex>\r\n\t\t\t#include <logdepthbuf_vertex>\r\n\t\t\t#include <clipping_planes_vertex>\r\n\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\r\n\t\t\t#include <worldpos_vertex>\r\n\t\t\t#include <envmap_vertex>\r\n\t\t\t#include <shadowmap_vertex>\r\n\t\t\t#include <fog_vertex>\r\n\r\n\t\t}\t\r\n\t";
	var phongShader = THREE.ShaderLib.phong;
	var unif = THREE.UniformsUtils .clone(phongShader.uniforms);
	unif.counter = { type : "f", value : 10000 * Math.random()};
	unif.specular.value = new THREE.Color(8947848);
	unif.emissive.value = new THREE.Color(2236962);
	THREE.ShaderMaterial.call(this,{ uniforms : unif, vertexShader : this.vv, fragmentShader : this.ff, lights : true});
	this.vertexColors = false;
	this.side = 2;
	this.blending = 3;
};
mat_MyShaderMat2.__super__ = THREE.ShaderMaterial;
mat_MyShaderMat2.prototype = $extend(THREE.ShaderMaterial.prototype,{
	update: function() {
		this.uniforms.counter.value += 0.001;
	}
});
var shader_SimplexNoise = function() {
};
var three_Face = function() { };
var three_IFog = function() { };
var three_Mapping = function() { };
var three_Renderer = function() { };
var utils_VectorUtils = function() {
};
utils_VectorUtils.limit = function(tgt,lim) {
	if(tgt.length() > lim) {
		tgt = tgt.normalize().multiplyScalar(lim);
	}
	return tgt;
};
utils_VectorUtils.$length = function(v1,v2) {
	var dx = v1.x - v2.x;
	var dy = v1.y - v2.y;
	var dz = v1.z - v2.z;
	var dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
	return dist;
};
var verlet_MojiShape = function() {
};
verlet_MojiShape.GetMoji = function() {
	var list = [verlet_MojiShape.S,verlet_MojiShape.T,verlet_MojiShape.R,verlet_MojiShape.U,verlet_MojiShape.C,verlet_MojiShape.T,verlet_MojiShape.U,verlet_MojiShape.R,verlet_MojiShape.E];
	verlet_MojiShape._count++;
	return list[verlet_MojiShape._count % list.length];
};
var verlet_VerletPoint = function() {
	this._prevPosition = new THREE.Vector3();
	if(verlet_VerletPoint._geo == null) {
		verlet_VerletPoint._geo = new THREE.IcosahedronGeometry(1.5,0);
	}
	if(verlet_VerletPoint._mat == null) {
		verlet_VerletPoint._mat = new THREE.MeshPhongMaterial({ color : color_MyColors.point});
	}
	THREE.Mesh.call(this,verlet_VerletPoint._geo,verlet_VerletPoint._mat);
};
verlet_VerletPoint.__super__ = THREE.Mesh;
verlet_VerletPoint.prototype = $extend(THREE.Mesh.prototype,{
	setPosition: function(px,py,pz) {
		if(this._firstPos == null) {
			this._firstPos = new THREE.Vector3(px,py,pz);
		}
		this.position.x = px;
		this.position.y = py;
		this.position.z = pz;
		this._prevPosition.x = px;
		this._prevPosition.y = py;
		this._prevPosition.z = pz;
	}
	,setVelocity: function(vx,vy,vz) {
		this._prevPosition.x = this.position.x - vx;
		this._prevPosition.y = this.position.y - vy;
		this._prevPosition.z = this.position.z - vz;
	}
	,setVelocityX: function(vx) {
		this._prevPosition.x = this.position.x - vx;
	}
	,setVelocityY: function(vy) {
		this._prevPosition.y = this.position.y - vy;
	}
	,setVelocityZ: function(vz) {
		this._prevPosition.z = this.position.z - vz;
	}
	,getVelocity: function() {
		return new THREE.Vector3(this.getVelocityX(),this.getVelocityY(),this.getVelocityZ());
	}
	,getVelocityLength: function() {
		var xx = this.getVelocityX();
		var yy = this.getVelocityY();
		var zz = this.getVelocityZ();
		return Math.sqrt(xx * xx + yy * yy + zz * zz);
	}
	,getVelocityX: function() {
		return this.position.x - this._prevPosition.x;
	}
	,getVelocityY: function() {
		return this.position.y - this._prevPosition.y;
	}
	,getVelocityZ: function() {
		return this.position.z - this._prevPosition.z;
	}
	,update: function() {
		var tmpX = this.position.x;
		var tmpY = this.position.y;
		var tmpZ = this.position.z;
		this.position.x += this.getVelocityX();
		this.position.y += this.getVelocityY();
		this.position.z += this.getVelocityZ();
		this.rotation.x += this.getVelocityX() * 0.01;
		this.rotation.y += this.getVelocityY() * 0.01;
		this.rotation.z += this.getVelocityZ() * 0.01;
		this._prevPosition.x = tmpX;
		this._prevPosition.y = tmpY;
		this._prevPosition.z = tmpZ;
	}
	,reset: function() {
		this.position.copy(this._firstPos);
		this._prevPosition.copy(this._firstPos);
	}
});
var verlet_VerletPoints = function() {
	THREE.Object3D.call(this);
	this._points = [];
	this._sticks = [];
};
verlet_VerletPoints.__super__ = THREE.Object3D;
verlet_VerletPoints.prototype = $extend(THREE.Object3D.prototype,{
	init: function() {
		console.log("init");
		var old = new THREE.Vector3();
		var N = 10;
		var text = verlet_MojiShape.GetMoji();
		var _g1 = 0;
		var _g = text.length;
		while(_g1 < _g) {
			var j = _g1++;
			var t = text[j];
			var _g3 = 0;
			var _g2 = t.length;
			while(_g3 < _g2) {
				var i = _g3++;
				if(HxOverrides.substr(t,i,1) == "O") {
					console.log("ok " + i + "_" + j);
					var _g4 = 0;
					while(_g4 < 2) {
						var k = _g4++;
						var p = new verlet_VerletPoint();
						this.add(p);
						this._points.push(p);
						p.setPosition((i - t.length / 2) * 25,-(j - (text.length - 1) / 2) * 25,(k - 0.5) * 25);
						p.setVelocity(8.1 * (Math.random() - 0.5),8.1 * (Math.random() - 0.5),2.1 * (Math.random() - 0.5));
					}
				}
			}
		}
		var _g11 = 0;
		var _g5 = this._points.length;
		while(_g11 < _g5) {
			var i1 = _g11++;
			var _g31 = 0;
			var _g21 = this._points.length;
			while(_g31 < _g21) {
				var j1 = _g31++;
				if(i1 != j1) {
					var dist = Math.sqrt(1250);
					if(this._points[i1].position.distanceTo(this._points[j1].position) <= dist + 0.5) {
						var stick = new verlet_VerletStick(this._points[i1],this._points[j1]);
						this._sticks.push(stick);
					}
				}
			}
		}
		var lineGeo = new THREE.Geometry();
		var _g12 = 0;
		var _g6 = this._sticks.length;
		while(_g12 < _g6) {
			var i2 = _g12++;
			lineGeo.vertices.push(new THREE.Vector3());
			lineGeo.vertices.push(new THREE.Vector3());
		}
		this._line = new THREE.LineSegments(lineGeo,new THREE.LineBasicMaterial({ color : color_MyColors.lineB}));
		this.add(this._line);
	}
	,_onHoge: function() {
		var _g1 = 0;
		var _g = this._sticks.length;
		while(_g1 < _g) {
			var i = _g1++;
			this._sticks[i].reset();
		}
	}
	,update: function() {
		var _g1 = 0;
		var _g = this._points.length;
		while(_g1 < _g) {
			var i = _g1++;
			var p = this._points[i];
			p.update();
			var masatsu = 0.8;
			if(p.position.x < -100.) {
				var vx = -p.getVelocityX() * masatsu;
				p.position.x = -100.;
				p.setVelocityX(vx);
			}
			if(p.position.x > 100.) {
				var vx1 = -p.getVelocityX() * masatsu;
				p.position.x = 100.;
				p.setVelocityX(vx1);
			}
			if(p.position.y < -100.) {
				var vy = -p.getVelocityY() * masatsu;
				p.position.y = -100.;
				p.setVelocityY(vy);
			}
			if(p.position.y > 100.) {
				var vy1 = -p.getVelocityY() * masatsu;
				p.position.y = 100.;
				p.setVelocityY(vy1);
			}
			if(p.position.z < -100.) {
				var vz = -p.getVelocityZ() * masatsu;
				p.position.z = -100.;
				p.setVelocityZ(vz);
			}
			if(p.position.z > 100.) {
				var vz1 = -p.getVelocityZ() * masatsu;
				p.position.z = 100.;
				p.setVelocityZ(vz1);
			}
			var len = p.getVelocityLength();
			var lim = 30;
			if(len > lim) {
				var vx2 = p.getVelocityX();
				var vy2 = p.getVelocityY();
				var vz2 = p.getVelocityZ();
				p.setVelocity(vx2 / len * lim,vy2,vz2);
			}
		}
		var _g11 = 0;
		var _g2 = this._sticks.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			this._sticks[i1].update();
			if(Math.random() < 0.0003 && this._sticks[i1].visible) {
				this._sticks[i1]._p1.setVelocity(60 * (Math.random() - 0.5),60 * (Math.random() - 0.5),60 * (Math.random() - 0.5));
			}
		}
		this._updateLine();
	}
	,_updateLine: function() {
		var _g1 = 0;
		var _g = this._sticks.length;
		while(_g1 < _g) {
			var i = _g1++;
			if(this._sticks[i].visible) {
				this._line.geometry.vertices[i * 2].copy(this._sticks[i]._p1.position);
				this._line.geometry.vertices[i * 2 + 1].copy(this._sticks[i]._p2.position);
			} else {
				this._line.geometry.vertices[i * 2].set(0,0,0);
				this._line.geometry.vertices[i * 2 + 1].set(0,0,0);
			}
		}
		this._line.geometry.verticesNeedUpdate = true;
	}
});
var verlet_VerletStick = function(p1,p2) {
	this.visible = true;
	this._count = 0;
	this._p1 = p1;
	this._p2 = p2;
	this.length = utils_VectorUtils.$length(this._p1.position,this._p2.position);
};
verlet_VerletStick.prototype = {
	update: function() {
		if(!this.visible) {
			return;
		}
		var dx = this._p1.position.x - this._p2.position.x;
		var dy = this._p1.position.y - this._p2.position.y;
		var dz = this._p1.position.z - this._p2.position.z;
		var dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
		var diff = this.length - dist;
		if(diff > 2 && this._count++ > 5) {
			this._count = 0;
			this.visible = false;
		}
		var mm = diff / dist * 0.5;
		var offsetX = dx * mm;
		var offsetY = dy * mm;
		var offsetZ = dz * mm;
		this._p1.position.x += offsetX;
		this._p1.position.y += offsetY;
		this._p1.position.z += offsetZ;
		this._p2.position.x -= offsetX;
		this._p2.position.y -= offsetY;
		this._p2.position.z -= offsetZ;
	}
	,reset: function() {
		if(Math.random() < 0.3) {
			this._count = 0;
			this._p1.reset();
			this._p2.reset();
		}
		this.visible = true;
	}
};
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
Cube.SIZE = 200;
Three.CullFaceNone = 0;
Three.CullFaceBack = 1;
Three.CullFaceFront = 2;
Three.CullFaceFrontBack = 3;
Three.FrontFaceDirectionCW = 0;
Three.FrontFaceDirectionCCW = 1;
Three.BasicShadowMap = 0;
Three.PCFShadowMap = 1;
Three.PCFSoftShadowMap = 2;
Three.FrontSide = 0;
Three.BackSide = 1;
Three.DoubleSide = 2;
Three.NoShading = 0;
Three.FlatShading = 1;
Three.SmoothShading = 2;
Three.NoColors = 0;
Three.FaceColors = 1;
Three.VertexColors = 2;
Three.NoBlending = 0;
Three.NormalBlending = 1;
Three.AdditiveBlending = 2;
Three.SubtractiveBlending = 3;
Three.MultiplyBlending = 4;
Three.CustomBlending = 5;
Three.AddEquation = 100;
Three.SubtractEquation = 101;
Three.ReverseSubtractEquation = 102;
Three.ZeroFactor = 200;
Three.OneFactor = 201;
Three.SrcColorFactor = 202;
Three.OneMinusSrcColorFactor = 203;
Three.SrcAlphaFactor = 204;
Three.OneMinusSrcAlphaFactor = 205;
Three.DstAlphaFactor = 206;
Three.OneMinusDstAlphaFactor = 207;
Three.MultiplyOperation = 0;
Three.MixOperation = 1;
Three.AddOperation = 2;
Three.RepeatWrapping = 1000;
Three.ClampToEdgeWrapping = 1001;
Three.MirroredRepeatWrapping = 1002;
Three.NearestFilter = 1003;
Three.NearestMipMapNearestFilter = 1004;
Three.NearestMipMapLinearFilter = 1005;
Three.LinearFilter = 1006;
Three.LinearMipMapNearestFilter = 1007;
Three.LinearMipMapLinearFilter = 1008;
Three.UnsignedByteType = 1009;
Three.ByteType = 1010;
Three.ShortType = 1011;
Three.UnsignedShortType = 1012;
Three.IntType = 1013;
Three.UnsignedIntType = 1014;
Three.FloatType = 1015;
Three.UnsignedShort4444Type = 1016;
Three.UnsignedShort5551Type = 1017;
Three.UnsignedShort565Type = 1018;
Three.AlphaFormat = 1019;
Three.RGBFormat = 1020;
Three.RGBAFormat = 1021;
Three.LuminanceFormat = 1022;
Three.LuminanceAlphaFormat = 1023;
Three.RGB_S3TC_DXT1_Format = 2001;
Three.RGBA_S3TC_DXT1_Format = 2002;
Three.RGBA_S3TC_DXT3_Format = 2003;
Three.RGBA_S3TC_DXT5_Format = 2004;
Three.LineStrip = 0;
Three.LinePieces = 1;
color_MyColors.bg = 0;
color_MyColors.lineA = 16777215;
color_MyColors.lineB = 16777215;
color_MyColors.point = 16777215;
color_MyColors.directionalLight = 16777215;
color_MyColors.ambientLight = 16777215;
shader_SimplexNoise.glsl = "\r\n//\r\n// Description : Array and textureless GLSL 2D/3D/4D simplex \r\n//               noise functions.\r\n//      Author : Ian McEwan, Ashima Arts.\r\n//  Maintainer : ijm\r\n//     Lastmod : 20110822 (ijm)\r\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\r\n//               Distributed under the MIT License. See LICENSE file.\r\n//               https://github.com/ashima/webgl-noise\r\n// \r\n\r\nvec3 mod289(vec3 x) {\r\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec4 mod289(vec4 x) {\r\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec4 permute(vec4 x) {\r\n\treturn mod289(((x*34.0)+1.0)*x);\r\n}\r\n\r\nvec4 taylorInvSqrt(vec4 r){\r\n\treturn 1.79284291400159 - 0.85373472095314 * r;\r\n}\r\n\r\nfloat snoise(vec3 v) { \r\n\r\n\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\r\n\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\r\n\r\n\t// First corner\r\n\tvec3 i  = floor(v + dot(v, C.yyy) );\r\n\tvec3 x0 =   v - i + dot(i, C.xxx) ;\r\n\r\n\t// Other corners\r\n\tvec3 g = step(x0.yzx, x0.xyz);\r\n\tvec3 l = 1.0 - g;\r\n\tvec3 i1 = min( g.xyz, l.zxy );\r\n\tvec3 i2 = max( g.xyz, l.zxy );\r\n\r\n\t//   x0 = x0 - 0.0 + 0.0 * C.xxx;\r\n\t//   x1 = x0 - i1  + 1.0 * C.xxx;\r\n\t//   x2 = x0 - i2  + 2.0 * C.xxx;\r\n\t//   x3 = x0 - 1.0 + 3.0 * C.xxx;\r\n\tvec3 x1 = x0 - i1 + C.xxx;\r\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\r\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\r\n\r\n\t// Permutations\r\n\ti = mod289(i); \r\n\tvec4 p = permute( permute( permute( \r\n\t\t  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\r\n\t\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \r\n\t\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\r\n\r\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\r\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\r\n\tfloat n_ = 0.142857142857; // 1.0/7.0\r\n\tvec3  ns = n_ * D.wyz - D.xzx;\r\n\r\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\r\n\r\n\tvec4 x_ = floor(j * ns.z);\r\n\tvec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\r\n\r\n\tvec4 x = x_ *ns.x + ns.yyyy;\r\n\tvec4 y = y_ *ns.x + ns.yyyy;\r\n\tvec4 h = 1.0 - abs(x) - abs(y);\r\n\r\n\tvec4 b0 = vec4( x.xy, y.xy );\r\n\tvec4 b1 = vec4( x.zw, y.zw );\r\n\r\n\t//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\r\n\t//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\r\n\tvec4 s0 = floor(b0)*2.0 + 1.0;\r\n\tvec4 s1 = floor(b1)*2.0 + 1.0;\r\n\tvec4 sh = -step(h, vec4(0.0));\r\n\r\n\tvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\r\n\tvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\r\n\r\n\tvec3 p0 = vec3(a0.xy,h.x);\r\n\tvec3 p1 = vec3(a0.zw,h.y);\r\n\tvec3 p2 = vec3(a1.xy,h.z);\r\n\tvec3 p3 = vec3(a1.zw,h.w);\r\n\r\n\t//Normalise gradients\r\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\r\n\tp0 *= norm.x;\r\n\tp1 *= norm.y;\r\n\tp2 *= norm.z;\r\n\tp3 *= norm.w;\r\n\r\n\t// Mix final noise value\r\n\tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\r\n\tm = m * m;\r\n\treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\r\n\r\n}\r\n\r\nvec3 snoiseVec3( vec3 x ){\r\n\r\n\tfloat s  = snoise(vec3( x ));\r\n\tfloat s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\r\n\tfloat s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\r\n\tvec3 c = vec3( s , s1 , s2 );\r\n\treturn c;\r\n\r\n}\r\n\r\nvec3 snoiseVec3Abs( vec3 x ){\r\n\r\n\tfloat s  = snoise(vec3( x ));\r\n\tfloat s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\r\n\tfloat s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\r\n\tvec3 c = vec3( abs(s) , abs(s1) , abs(s2) );\r\n\treturn c;\r\n\r\n}\r\n\r\n\r\nvec3 curlNoise( vec3 p ){\r\n \r\n\tconst float e = .1;\r\n\tvec3 dx = vec3( e   , 0.0 , 0.0 );\r\n\tvec3 dy = vec3( 0.0 , e   , 0.0 );\r\n\tvec3 dz = vec3( 0.0 , 0.0 , e   );\r\n\r\n\tvec3 p_x0 = snoiseVec3( p - dx );\r\n\tvec3 p_x1 = snoiseVec3( p + dx );\r\n\tvec3 p_y0 = snoiseVec3( p - dy );\r\n\tvec3 p_y1 = snoiseVec3( p + dy );\r\n\tvec3 p_z0 = snoiseVec3( p - dz );\r\n\tvec3 p_z1 = snoiseVec3( p + dz );\r\n\r\n\tfloat x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\r\n\tfloat y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\r\n\tfloat z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\r\n\r\n\tconst float divisor = 1.0 / ( 2.0 * e );\r\n\treturn normalize( vec3( x , y , z ) * divisor );\r\n\r\n}\r\n\r\nvec3 curlNoise2( vec3 p ) {\r\n\r\n\tconst float e = .1;\r\n\r\n\tvec3 xNoisePotentialDerivatives = snoiseVec3( p );\r\n\tvec3 yNoisePotentialDerivatives = snoiseVec3( p + e * vec3( 3., -3.,  1. ) );\r\n\tvec3 zNoisePotentialDerivatives = snoiseVec3( p + e * vec3( 2.,  4., -3. ) );\r\n\r\n\tvec3 noiseVelocity = vec3(\r\n\t\tzNoisePotentialDerivatives.y - yNoisePotentialDerivatives.z,\r\n\t\txNoisePotentialDerivatives.z - zNoisePotentialDerivatives.x,\r\n\t\tyNoisePotentialDerivatives.x - xNoisePotentialDerivatives.y\r\n\t);\r\n\r\n\treturn normalize( noiseVelocity );\r\n\r\n}\r\n\r\nvec4 snoiseD(vec3 v) { //returns vec4(value, dx, dy, dz)\r\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\r\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\r\n \r\n  vec3 i  = floor(v + dot(v, C.yyy) );\r\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\r\n \r\n  vec3 g = step(x0.yzx, x0.xyz);\r\n  vec3 l = 1.0 - g;\r\n  vec3 i1 = min( g.xyz, l.zxy );\r\n  vec3 i2 = max( g.xyz, l.zxy );\r\n \r\n  vec3 x1 = x0 - i1 + C.xxx;\r\n  vec3 x2 = x0 - i2 + C.yyy;\r\n  vec3 x3 = x0 - D.yyy;\r\n \r\n  i = mod289(i);\r\n  vec4 p = permute( permute( permute(\r\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\r\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\r\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\r\n \r\n  float n_ = 0.142857142857; // 1.0/7.0\r\n  vec3  ns = n_ * D.wyz - D.xzx;\r\n \r\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\r\n \r\n  vec4 x_ = floor(j * ns.z);\r\n  vec4 y_ = floor(j - 7.0 * x_ );\r\n \r\n  vec4 x = x_ *ns.x + ns.yyyy;\r\n  vec4 y = y_ *ns.x + ns.yyyy;\r\n  vec4 h = 1.0 - abs(x) - abs(y);\r\n \r\n  vec4 b0 = vec4( x.xy, y.xy );\r\n  vec4 b1 = vec4( x.zw, y.zw );\r\n \r\n  vec4 s0 = floor(b0)*2.0 + 1.0;\r\n  vec4 s1 = floor(b1)*2.0 + 1.0;\r\n  vec4 sh = -step(h, vec4(0.0));\r\n \r\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\r\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\r\n \r\n  vec3 p0 = vec3(a0.xy,h.x);\r\n  vec3 p1 = vec3(a0.zw,h.y);\r\n  vec3 p2 = vec3(a1.xy,h.z);\r\n  vec3 p3 = vec3(a1.zw,h.w);\r\n \r\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\r\n  p0 *= norm.x;\r\n  p1 *= norm.y;\r\n  p2 *= norm.z;\r\n  p3 *= norm.w;\r\n \r\n  vec4 values = vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ); //value of contributions from each corner (extrapolate the gradient)\r\n \r\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0); //kernel function from each corner\r\n \r\n  vec4 m2 = m * m;\r\n  vec4 m3 = m * m * m;\r\n \r\n  vec4 temp = -6.0 * m2 * values;\r\n  float dx = temp[0] * x0.x + temp[1] * x1.x + temp[2] * x2.x + temp[3] * x3.x + m3[0] * p0.x + m3[1] * p1.x + m3[2] * p2.x + m3[3] * p3.x;\r\n  float dy = temp[0] * x0.y + temp[1] * x1.y + temp[2] * x2.y + temp[3] * x3.y + m3[0] * p0.y + m3[1] * p1.y + m3[2] * p2.y + m3[3] * p3.y;\r\n  float dz = temp[0] * x0.z + temp[1] * x1.z + temp[2] * x2.z + temp[3] * x3.z + m3[0] * p0.z + m3[1] * p1.z + m3[2] * p2.z + m3[3] * p3.z;\r\n \r\n  return vec4(dot(m3, values), dx, dy, dz) * 42.0;\r\n}\r\n\r\n\r\nvec3 curlNoise3 (vec3 p) {\r\n\r\n    vec3 xNoisePotentialDerivatives = snoiseD( p ).yzw; //yzw are the xyz derivatives\r\n    vec3 yNoisePotentialDerivatives = snoiseD(vec3( p.y - 19.1 , p.z + 33.4 , p.x + 47.2 )).zwy;\r\n    vec3 zNoisePotentialDerivatives = snoiseD(vec3( p.z + 74.2 , p.x - 124.5 , p.y + 99.4 )).wyz;\r\n    vec3 noiseVelocity = vec3(\r\n        zNoisePotentialDerivatives.y - yNoisePotentialDerivatives.z,\r\n        xNoisePotentialDerivatives.z - zNoisePotentialDerivatives.x,\r\n        yNoisePotentialDerivatives.x - xNoisePotentialDerivatives.y\r\n    );\r\n\t\r\n\tconst float e = .1;\r\n\tconst float divisor = 1.0 / ( 2.0 * e );\r\n\treturn normalize( noiseVelocity * divisor );\r\n\r\n}\r\n\t\r\n\t";
verlet_MojiShape.A = ["____OO____","___OOOO___","__OO__OO__","__OOOOOO__","__OOOOOO__","__OO__OO__","__OO__OO__"];
verlet_MojiShape.S = ["_OOOO_","OOOOOO","OO____","OOOOO_","_OOOOO","____OO","OOOOOO","_OOOO_"];
verlet_MojiShape.T = ["OOOOOO","OOOOOO","__OO__","__OO__","__OO__","__OO__","__OO__","__OO__"];
verlet_MojiShape.U = ["OO__OO","OO__OO","OO__OO","OO__OO","OO__OO","OO__OO","OOOOOO","_OOOO_"];
verlet_MojiShape.R = ["_OOOO_","OOOOOO","OO__OO","OO__OO","OOOOO_","OOOOOO","OO__OO","OO__OO"];
verlet_MojiShape.C = ["_OOOOO","OOOOOO","OO____","OO____","OO____","OO____","OOOOOO","_OOOOO"];
verlet_MojiShape.E = ["OOOOOO","OOOOOO","OO____","OOOOOO","OOOOOO","OO____","OOOOOO","OOOOOO"];
verlet_MojiShape._count = -1;
Main.main();
})();